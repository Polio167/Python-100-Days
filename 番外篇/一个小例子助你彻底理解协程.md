## 一個小例子助你徹底理解協程

協程，可能是Python中最讓初學者困惑的知識點之一，它也是Python中實現併發程式設計的一種重要方式。Python中可以使用多執行緒和多程序來實現併發，這兩種方式相對來說是大家比較熟悉的。事實上，還有一種實現併發的方式叫做非同步程式設計，而協程就是實現非同步程式設計的必要方式。

所謂協程，可以簡單的理解為多個相互協作的子程式。在同一個執行緒中，當一個子程式阻塞時，我們可以讓程式馬上從一個子程式切換到另一個子程式，從而避免CPU因程式阻塞而閒置，這樣就可以提升CPU的利用率，相當於用一種協作的方式加速了程式的執行。所以，我們可以言簡意賅的說：**協程實現了協作式併發**。

接下來用一個小例子幫助大家理解什麼是協作式併發，先看看下面的程式碼。

```Python
import time


def display(num):
    time.sleep(1)
    print(num)


for num in range(10):
    display(num)
```

上面這段程式碼相信大家很容看懂，程式會輸出0到9的數字，每隔1秒中輸出一個數字，因此整個程式的執行需要大約10秒時間。值得注意的是，因為沒有使用多執行緒或多程序，程式中只有一個執行單元，而`time.sleep(1)`的休眠操作會讓整個執行緒停滯1秒鐘，對於上面的程式碼來說，在這段時間裡面CPU是完全閒置的沒有做什麼事情。

我們再來看看使用協程會發生什麼事情。從Python 3.5開始，使用協程實現協作式編髮有了更為便捷的語法，我們可以使用`async`來定義非同步函式，可以使用`await`讓一個阻塞的子程式將CPU讓給與它協作的子程式。在Python 3.7中，`asyanc`和`await`成為了正式的關鍵字，讓開發者有一種喜大普奔的感覺。我們先看看如何定義一個非同步函式。

```Python
import asyncio


async def display(num):
    await asyncio.sleep(1)
    print(num)
```

接下來敲黑板說重點。非同步函式不同於普通函式，呼叫普通函式會得到返回值，而呼叫非同步函式會得到一個協程物件。我們需要將協程物件放到一個事件迴圈中才能達到與其他協程物件協作的效果，因為事件迴圈會負責處理子程式切換的操作，簡單的說就是讓阻塞的子程式讓出CPU給可以執行的子程式。

我們先透過下面的列表生成式來程式碼10個協程物件，跟剛才在迴圈中呼叫display函式的道理一致。

```Python
coroutines = [display(num) for num in range(10)]
```

透過下面的程式碼可以獲取事件迴圈並將協程物件放入事件迴圈中。

```Python
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(coroutines))
loop.close()
```

執行上面的程式碼會發現，10個分別會阻塞1秒鐘的協程總共只阻塞了約1秒種的時間，這就說明**協程物件一旦阻塞會將CPU讓出而不是讓CPU處於閒置狀態**，這樣就大大的**提升了CPU的利用率**。而且我們還會注意到，0到9的數字並不是按照我們建立協程物件的順序打印出來的，這正是我們想要的結果啊；另外，多次執行該程式會發現每次輸出的結果都不太一樣，這正是併發程式本身執行順序不確定性造成的結果。

上面的例子來自於著名的“花書”（《Python高階併發程式設計》），為了讓大家對協程的體會更加深刻，對原書的程式碼做了小的改動，這個例子雖然簡單，但是它已經讓你體會到了協作式併發的魅力。在商業專案中，如果需要使用協作式併發，還可以將系統預設的事件迴圈替換為`uvloop`提供的事件迴圈，這樣會獲得更好的效能，因為`uvloop`是基於著名的跨平臺非同步I/O庫libuv實現的。另外，如果要做基於HTTP的網路程式設計，三方庫**aiohttp**是不錯的選擇，它基於asyncio實現了非同步的HTTP伺服器和客戶端。